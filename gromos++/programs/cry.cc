/**
 * @file cry.cc
 * Perform symmetry operations on molecules
 */

/**
 * @page programs Program Documentation
 *
 * @anchor cry
 * @section cry Perform symmetry operations on molecules
 * @author @ref mc @ref co
 * @date 8-6-07
 *
 * When using periodic boundary conditions, the computational box containing
 * the molecular system is treated as being translationally invariant. So,
 * periodic boundary conditions can also be used when simulating a crystal as
 * long as the unit cell, or a number of adjacent unit cells is used as
 * computational box. Unless the asymmetric unit is translationally invariant,
 * it cannot be used a computational box. Since crystallographic coordinates of
 * moleculars are generally only provided for the molecules in one asymmetric
 * unit, the coordinates of the other molecules in the unit cell or cells are
 * to be generated by crystallographic symmetry transformations.
 *
 * The program cry can rotate and translate copies of a system to create a 
 * crystal unit cell. Based on a topology and initial (gathered) coordinates,
 * as well as a specification file for the symmetry transformations. A
 * conversion factor can also be given if the translation vector is specified
 * in different units than the coordinates. A coordinate file is generated that
 * contains coordinates for as many systems as there are transformations
 * defined in the specification file. The corresponding topology can easily be
 * generated using the program @ref com_top (section V-2.2).
 *
 * <b>arguments:</b>
 * <table border=0 cellpadding=0>
 * <tr><td> \@topo</td><td>&lt;molecular topology file&gt; </td></tr>
 * <tr><td> \@pos</td><td>&lt;input coordinate file for the molecules&gt; </td></tr>
 * <tr><td> \@spec</td><td>&lt;specification file for the symmetry transformations </td></tr>
 * <tr><td> \@factor</td><td>&lt;conversion factor for distances&gt; </td></tr>
 * </table>
 *
 *
 * Example:
 * @verbatim
  cry
    @topo    ex.top
    @pos     exref.coo
    @spec    procry.spec
    @factor  0.1
 @endverbatim
 *
 * <hr>
 */

#include <cassert>
#include <vector>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <cmath>
#include <iostream>

#include "../src/args/Arguments.h"
#include "../src/fit/PositionUtils.h"
#include "../src/gio/InG96.h"
#include "../src/gio/OutG96S.h"
#include "../src/gcore/System.h"
#include "../src/gcore/Molecule.h"
#include "../src/gcore/Solvent.h"
#include "../src/gcore/Box.h"
#include "../src/gio/Ginstream.h"
#include "../src/gio/InTopology.h"
#include "../src/gmath/Matrix.h"
#include "../src/gmath/Vec.h"
#include "../src/bound/RectBox.h"

using namespace std;
using namespace gcore;
using namespace gio;
using namespace fit;
using namespace gmath;
using namespace bound;
using namespace args;

void read_spec(std::string name, 
	       vector<Matrix> & rotation, 
	       vector<Vec> &translation, 
	       double factor);

int main(int argc, char **argv){

  char *knowns[] = {"topo", "pos", "spec", "factor"};  

  int nknowns = 4;

  string usage = "# " + string(argv[0]);
  usage += "\n\t@topo   <molecular topology file>\n";
  usage += "\t@pos    <input coordinate file for the molecules>\n";
  usage += "\t@spec   <specification file for the symmetry transformations\n";
  usage += "\t@factor <conversion factor for distances>\n";

  try{
    Arguments args(argc, argv, nknowns, knowns, usage);

    // read topology
    args.check("topo",1);
    InTopology it(args["topo"]);
    System sys(it.system());
    
    // read the conversion factor
    double factor=1;
    if(args.count("factor")>0) factor=atof(args["factor"].c_str());
 
    // read the specification file
    vector<Matrix> rotation;
    vector<Vec> translation;
    read_spec(args["spec"], rotation, translation, factor);

    // create a final system to work on here.
    // tell it already about the solvent that we have
    System finalsys;
    finalsys.addSolvent(sys.sol(0));
    
    // read single coordinates
    InG96 ic;
    ic.open(args["pos"]);
    ic.select("ALL");
    ic >> sys;
    ic.close();    

    // create one more system to keep the coordinates
    System refsys(sys);
    
    int num=rotation.size();
    for(int i=0; i< num; ++i){
      //solute
      for(int m=0; m<sys.numMolecules(); ++m){
	for(int a=0; a<sys.mol(m).numAtoms(); ++a){
	  sys.mol(m).pos(a) = rotation[i]*refsys.mol(m).pos(a) 
	    + translation[i];
	}
	finalsys.addMolecule(sys.mol(m));
      }
      //solvent
      for(int s=0; s<sys.sol(0).numPos(); ++s){
	finalsys.sol(0).addPos(rotation[i]*refsys.sol(0).pos(s)
			       + translation[i]);
      }
    }

    // Print the new set to cout
    OutG96S oc;
    ostringstream title;
    title << "PROCRY did something for you!";

    oc.open(cout);
    oc.select("ALL");
    
    oc.writeTitle(title.str());
    oc << finalsys;
  }
  catch (const gromos::Exception &e){
    cerr << e.what() << endl;
    exit(1);
  }
  return 0;
}




void read_spec(std::string name, 
	       vector<Matrix> & rotation, 
	       vector<Vec> &translation, 
	       double factor)
{
  Ginstream file(name);
  vector<string> buffer;
  file.getblock(buffer);
  file.close();
  
  if(buffer[0]!="TRANSFORM")
    throw gromos::Exception("procry","Could not read TRANSFORM block in specification file");
  if(buffer[buffer.size()-1].find("END")!=0)
    throw gromos::Exception("procry", "Specification file " + file.name() +
			    " is corrupted. No END in "+buffer[0]+
			    " block. Got\n"
			    + buffer[buffer.size()-1]);
  int num=0;
  vector<string>::iterator iter=buffer.begin()+1;

  istringstream is(*iter);
  ++iter;

  if(!(is >> num) || num <=0)
    throw gromos::Exception("procry", "Need some transformations");
  if(buffer.size() - 3 != unsigned (num * 3))
    throw gromos::Exception("procry", "Line count wrong in " +file.name());
  
  Matrix rot(3,3);
  Vec v;

  for(int i=0; i< num; i++){
    for(int j=0; j < 3; j++, ++iter){
      is.clear();
      is.str(*iter);
      for(int k=0; k< 3; ++k){
	if(!(is >> rot(j,k)))
	   throw gromos::Exception("procry", "error reading file");
      }
      if(!(is >> v[j]))
	throw gromos::Exception("procry", "error reading file");
    }
    rotation.push_back(rot);
    translation.push_back(factor*v);
  }
  
}

  
    
  
